import * as vscode from "vscode";

export function registerCommands(context: vscode.ExtensionContext): void {
  /**
   * Formatting MML generated by PetiteMM
   * @param textEditor
   * @param edit
   */
  async function commandPetiteMM(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {
    let doc = textEditor.document;

    //exist #amk
    if ((doc.getText().match(/#amk/gi) ?? []).length > 0) {
      vscode.window.showWarningMessage('This is a command to format MML made by PetiteMM. "#amk" command needs to be removed.');
    }

    //doesn't exist
    else if ((doc.getText().match(/;/g) ?? []).length < 1) {
      vscode.window.showWarningMessage("Channel does not exist.");
    }

    //too many channels
    else if ((doc.getText().match(/;/g) ?? []).length > 8) {
      vscode.window.showWarningMessage("Too many channels!");
    } else {
      //reverse octave command check
      const doOctaveReverse = await vscode.window.showQuickPick(["No", "Yes"], {
        placeHolder: "Reverse octave command? (<→>,>→<)",
      });

      let textArray: string[] = [];
      let channelCount = 0;

      textArray.push("#amk 2\r\n");
      textArray.push("#spc");
      textArray.push("{");
      textArray.push('\t#author "Author\'s name"');
      textArray.push('\t#game	"Game\'s name"');
      textArray.push('\t#comment "A comment"');
      textArray.push('\t#title	"Song\'s name"');
      textArray.push("}\r\n");

      for (let lineIndex = 0; lineIndex < doc.lineCount; lineIndex++) {
        let text = doc.lineAt(lineIndex).text;
        let tempo;

        //tempo(t)
        if ((tempo = text.match(/(?<=t)\d+/g)) !== null) {
          text = text.replace(tempo[0], Math.round(parseInt(tempo[0]) * 0.4).toString());
        }

        //channel(;)
        else if (text === ";") {
          text = text.replace(";", "\r\n#" + channelCount);
          channelCount++;
        } else {
          //tie(^)
          text = text.replace(/\^[abcdefg][\+\-]?/g, "^");

          //Octave(<,>)
          if (doOctaveReverse === "Yes") {
            text = text.replace("<", "_");
            text = text.replace(">", "<");
            text = text.replace("_", ">");
          }
        }

        textArray.push(text);
      }
      textEditor.edit((editBuilder) => editBuilder.replace(new vscode.Range(doc.positionAt(0), doc.positionAt(doc.getText().length)), textArray.join("\r\n")));
    }
  }

  /**
   * Drum assignments
   * @param textEditor
   * @param edit
   */
  async function commandDrum(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {
    let doc = textEditor.document;

    let channelLineIndex = -1;

    for (let lineIndex = textEditor.selection.start.line; lineIndex >= 0; lineIndex--) {
      let text = doc.lineAt(lineIndex).text;

      //channel(#)
      if (text.match(/#\d+/g) !== null) {
        channelLineIndex = lineIndex;
        break;
      }
    }

    if (channelLineIndex < 0) {
      vscode.window.showWarningMessage("The cursor is outside the channel. Move the cursor inside the channel.");
      return;
    }

    const argument = await vscode.window.showInputBox({
      placeHolder: "Enter the values. Format : instrument(string), octave, note (e.g. @30,4,c)",
    });

    //cancel
    if (argument === undefined) {
      return;
    }

    let argumentArray = argument.split(",").map((str) => str.trim());

    //number of arguments check
    if (argumentArray.length !== 3) {
      vscode.window.showWarningMessage("Must be 3 arguments.");
      return;
    }

    //argument 1
    //empty check
    if (argumentArray[0] === "") {
      vscode.window.showWarningMessage("Argument 1 (instrument) is not entered.");
      return;
    }

    //argument 2
    //empty check
    if (argumentArray[1] === "") {
      vscode.window.showWarningMessage("Argument 2 (octave) is not entered.");
      return;
    }
    //range check (1-6)
    else if (!(1 <= parseInt(argumentArray[1]) && parseInt(argumentArray[1]) <= 6)) {
      vscode.window.showWarningMessage("Valid values of argument 2 (octave) are 1 to 6.");
      return;
    }

    for (let lineIndex = channelLineIndex; lineIndex < doc.lineCount; lineIndex++) {
      let text = doc.lineAt(lineIndex).text;

      //channel(#)
      if (lineIndex !== channelLineIndex && text.match(/#\d+/g) !== null) {
        break;
      }
    }
  }

  context.subscriptions.push(vscode.commands.registerTextEditorCommand("mmlamktoolkit.petitemm", commandPetiteMM));
  context.subscriptions.push(vscode.commands.registerTextEditorCommand("mmlamktoolkit.drum", commandDrum));
}
