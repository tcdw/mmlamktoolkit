import * as vscode from "vscode";
import { regexMap } from "./map";

export function registerCommands(context: vscode.ExtensionContext): void {
  /**
   * Formatting MML generated by PetiteMM
   * @param textEditor
   * @param edit
   */
  async function commandPetiteMM(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {
    let doc = textEditor.document;

    //exist #amk
    if ((doc.getText().match(/#amk/gi) ?? []).length > 0) {
      vscode.window.showWarningMessage('This is a command to format MML made by PetiteMM. "#amk" command needs to be removed.');
    }

    //doesn't exist
    else if ((doc.getText().match(/;/g) ?? []).length < 1) {
      vscode.window.showWarningMessage("Channel does not exist.");
    }

    //too many channels
    else if ((doc.getText().match(/;/g) ?? []).length > 8) {
      vscode.window.showWarningMessage("Too many channels!");
    } else {
      //reverse octave command check
      const doOctaveReverse = await vscode.window.showQuickPick(["No", "Yes"], {
        title: "Reverse octave command? (<→>,>→<)",
      });

      let textArray: string[] = [];
      let channelCount = 0;

      textArray.push("#amk 2\r\n");
      textArray.push("#spc");
      textArray.push("{");
      textArray.push('\t#author "Author\'s name"');
      textArray.push('\t#game	"Game\'s name"');
      textArray.push('\t#comment "A comment"');
      textArray.push('\t#title	"Song\'s name"');
      textArray.push("}\r\n");

      for (let lineIndex = 0; lineIndex < doc.lineCount; lineIndex++) {
        let text = doc.lineAt(lineIndex).text;
        let tempo;

        //tempo(t)
        if ((tempo = text.match(/(?<=t)\d+/g)) !== null) {
          text = text.replace(tempo[0], Math.round(parseInt(tempo[0]) * 0.4).toString());
        }

        //channel(;)
        else if (text === ";") {
          text = text.replace(";", "\r\n#" + channelCount);
          channelCount++;
        } else {
          //tie(^)
          text = text.replace(/\^[abcdefg][\+\-]?/g, "^");

          //Octave(<,>)
          if (doOctaveReverse === "Yes") {
            text = text.replace("<", "_");
            text = text.replace(">", "<");
            text = text.replace("_", ">");
          }
        }

        textArray.push(text);
      }
      textEditor.edit((editBuilder) => editBuilder.replace(new vscode.Range(doc.positionAt(0), doc.positionAt(doc.getText().length)), textArray.join("\r\n")));
    }
  }

  /**
   * Drum assignments
   * @param textEditor
   * @param edit
   */
  async function commandDrum(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {
    let doc = textEditor.document;

    let channelLineIndex = -1;
    let drumArray: { instrument: string; octave: number; note: number }[] = [];
    let currentValue: { instrument: string; octave: number } = { instrument: "", octave: -1 };
    let textArray: string[] = [];

    for (let lineIndex = textEditor.selection.start.line; lineIndex >= 0; lineIndex--) {
      let text = doc.lineAt(lineIndex).text;

      //channel(#)
      if (text.match(/#\d+/g) !== null) {
        channelLineIndex = lineIndex;
        break;
      }
    }

    if (channelLineIndex < 0) {
      vscode.window.showWarningMessage("The cursor is outside the channel. Move the cursor inside the channel.");
      return;
    }

    //imput arguments
    while (true) {
      const argument = await vscode.window.showInputBox({
        placeHolder: "Format : instrument(string), octave, note (e.g. @30,4,c)",
        prompt: "If Enter is entered while nothing is typed, it is confirmed. ",
        title: "Enter the instrument to be assigned (any string) and the target pitch.",
      });

      //cancel
      if (argument === undefined) {
        return;
      }

      //confirm
      else if (argument === "") {
        if (drumArray.length === 0) {
          vscode.window.showWarningMessage("No arguments have been entered!");
          continue;
        }
        break;
      }

      let argumentArray = argument.split(",").map((str) => str.trim());

      //number of arguments check
      if (argumentArray.length !== 3) {
        vscode.window.showWarningMessage("Must be 3 arguments.");
        continue;
      }

      //argument 1
      //empty check
      if (argumentArray[0] === "") {
        vscode.window.showWarningMessage("Argument 1 (instrument) is not entered.");
        continue;
      }

      //argument 2
      //empty check
      if (argumentArray[1] === "") {
        vscode.window.showWarningMessage("Argument 2 (octave) is not entered.");
        continue;
      }
      //range check (1-6)
      else if (!(1 <= parseInt(argumentArray[1]) && parseInt(argumentArray[1]) <= 6)) {
        vscode.window.showWarningMessage("Valid values of argument 2 (octave) are 1 to 6.");
        continue;
      }

      //argument 3
      //empty check
      if (argumentArray[2] === "") {
        vscode.window.showWarningMessage("Argument 3 (note) is not entered.");
        continue;
      }
      //note check
      else if (noteToPitch(argumentArray[2].toLowerCase()) === NaN) {
        vscode.window.showWarningMessage("Argument 3 must be in note format.");
        continue;
      }

      drumArray.push({ instrument: argumentArray[0], octave: parseInt(argumentArray[1]), note: noteToPitch(argumentArray[2].toLowerCase()) });
      vscode.window.showInformationMessage('"' + argument + '" has been entered!');
    }

    let lineIndex: number;
    for (lineIndex = channelLineIndex; lineIndex < doc.lineCount; lineIndex++) {
      let text = doc.lineAt(lineIndex).text;

      //channel(#)
      if (lineIndex !== channelLineIndex && text.match(/#\d+/g) !== null) {
        break;
      }

      //Exclude comment(;)
      if (text.includes(";")) {
        const index = text.indexOf(";");
        if (index === 0) {
          continue;
        }
        text = text.substring(0, index);
      }

      let drumIndexArray: { instrument: string; index: number }[] = [];

      let regex = new RegExp([regexMap.note, regexMap.octave, regexMap.octaveLower, regexMap.octaveRaise].join("|"), "g");
      let match;

      while ((match = regex.exec(text)) !== null) {
        if (match.groups !== undefined) {
          //note
          if (match.groups.note !== undefined) {
            for (const drum of drumArray) {
              if (currentValue.octave === drum.octave && noteToPitch(match.groups.notePitch.toLowerCase()) === drum.note && currentValue.instrument !== drum.instrument) {
                currentValue.instrument = drum.instrument;
                drumIndexArray.push({ instrument: currentValue.instrument, index: match.index });
                break;
              }
            }
          }

          //octave
          else if (match.groups.octave !== undefined) {
            currentValue.octave = parseInt(match.groups.octaveValue);
          }

          //octaveLower
          else if (match.groups.octaveLower !== undefined) {
            currentValue.octave--;
          }

          //octaveRaise
          else if (match.groups.octaveRaise !== undefined) {
            currentValue.octave++;
          }
        }
      }

      if (drumIndexArray.length > 0) {
        for (const drumIndex of drumIndexArray.reverse()) {
          text = text.slice(0, drumIndex.index) + " " + drumIndex.instrument + " " + text.slice(drumIndex.index);
        }
      }

      textArray.push(text);
    }
    textEditor.edit((editBuilder) => editBuilder.replace(new vscode.Range(channelLineIndex, 0, lineIndex - 1, doc.lineAt(lineIndex - 1).text.length), textArray.join("\r\n")));

    function noteToPitch(note: string): number {
      switch (note) {
        case "c-":
          return 11;

        case "c":
          return 0;

        case "c+":
          return 1;

        case "d-":
          return 1;

        case "d":
          return 2;

        case "d+":
          return 3;

        case "e-":
          return 3;

        case "e":
          return 4;

        case "e+":
          return 5;

        case "f-":
          return 4;

        case "f":
          return 5;

        case "f+":
          return 6;

        case "g-":
          return 6;

        case "g":
          return 7;

        case "g+":
          return 8;

        case "a-":
          return 8;

        case "a":
          return 9;

        case "a+":
          return 10;

        case "b-":
          return 10;

        case "b":
          return 11;

        case "b+":
          return 0;

        default:
          return NaN;
      }
    }
  }

  context.subscriptions.push(vscode.commands.registerTextEditorCommand("mmlamktoolkit.petitemm", commandPetiteMM));
  context.subscriptions.push(vscode.commands.registerTextEditorCommand("mmlamktoolkit.drum", commandDrum));
}
